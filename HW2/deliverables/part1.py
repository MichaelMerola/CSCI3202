import GAinspector
#import numpy as np
from utils import *
from statistics import mean
import random

def stringify(s):
    return ''.join(str(e) for e in s)

def randomGenome(length):
    """
    :param length:
    :return: string, random binary digit
    """
    """Your Code Here"""
    gen = [random.randint(0,1) for i in range(length)]

    return stringify(gen)
#end randomGenome
        

def makePopulation(size, length):
    """
    :param size - of population:
    :param length - of genome
    :return: list of length size containing genomes of length length
    """

    """Your Code Here"""

    pop = []
    for i in range(size):
        pop.append(randomGenome(length))

    return pop
#end makePopulation


def fitness(genome):
    """
    :param genome: 
    :return: the fitness value of a genome
    """
    return genome.count('1')
#end fitness

def evaluateFitness(population):
    """
    :param population: 
    :return: a pair of values: the average fitness of the population as a whole and the fitness of the best individual in the population.
    """
    best = 0
    average = 0
    for n in population:
        f = fitness(n)

        average += f

        if (f >= best):
            best = f

    overall_avg = average/len(population)

    return (overall_avg, best)
#end evaluateFitness

def crossover(genome1, genome2):
    """
    :param genome1:
    :param genome2:
    :return: two new genomes produced by crossing over the given genomes at a random crossover point.
    """
    #find crossover point, in case the genomes are different lengths
    minlength = min([len(genome1), len(genome2)])
    split = random.randint(1, minlength-1)
    #print('split', split)

    #split genomes
    g1_prefix = genome1[:split]
    g1_suffix = genome1[split:]

    g2_prefix = genome2[:split]
    g2_suffix = genome2[split:]

    #cross genomes
    new_g1 = g1_prefix + g2_suffix
    new_g2 = g2_prefix + g1_suffix

    #print(new_g1)
    #print(new_g2)

    return (new_g1, new_g2)
#end crossover

def mutate(genome, mutationRate):
    """
    :param genome:
    :param mutationRate:
    :return: a new mutated version of the given genome.
    """
    new_gen = ''

    for i in genome:
        r = random.uniform(0, 1)

        if (r <= mutationRate):
            #flip
            if (i == '0'):
                i = '1'
            else:
                i = '0'

        new_gen += i

    return new_gen
#end mutate

def selectPair(population):
    """

    :param population:
    :return: two genomes from the given population using fitness-proportionate selection. 
    This function should use weightedChoice, which we wrote in class, as a helper function.
    """
    weights = []
    for n in population:
        weights.append(fitness(n))

    gen_1 = weightedChoice(population, weights)
    gen_2 = weightedChoice(population, weights)

    return (gen_1, gen_2)
#end selectPair

def runGA(populationSize, crossoverRate, mutationRate, logFile=""):
    """

    :param populationSize: :param crossoverRate: :param mutationRate: :param logFile: :return: xt file in which to
    store the data generated by the GA, for plotting purposes. When the GA terminates, this function should return
    the generation at which the string of all ones was found.is the main GA program, which takes the population size,
    crossover rate (pc), and mutation rate (pm) as parameters. The optional logFile parameter is a string specifying
    the name of a te
    """
    file = open(logFile, 'w')
    genome_length = 20
    
    gen_zero = makePopulation(populationSize, genome_length)
    count_gens = 1
    current_gens = gen_zero

    print("Population Size = ", populationSize)
    print("Genome Length = ", genome_length)

    while count_gens <= 50:

        #evaluate current
        current_fit = evaluateFitness(current_gens)
        print("Generation ", count_gens, ": average fit = ", current_fit[0], ", best fit = ", current_fit[1])
        send = str(count_gens) + "\t" + str(current_fit[0]) + "\t" + str(current_fit[1]) + "\n"
        file.write(send)

        if (current_fit[1] == genome_length):
            return (count_gens, current_fit[0], current_fit[1])

        #build new gen
        #count_new = 0
        gen_new = []
        while len(gen_new) < populationSize:

            #choose parents
            chosen = selectPair(current_gens)

            #crossover
            children = chosen
            cr = random.uniform(0, 1)
            if (cr <= crossoverRate):
                children = crossover(chosen[0], chosen[1])

            #mutation
            mute_child1 = mutate(children[0], mutationRate)
            mute_child2 = mutate(children[0], mutationRate)

            #add to new gen
            gen_new.append(mute_child1)
            gen_new.append(mute_child2)

        #end buildnewgen

        current_gens = gen_new
        count_gens += 1
    #end while

    file.close()
    return None
#end runGA

def reportTester(runtime, pop, cross, mute):

    generationsFound = []
    noneCount = 0

    for n in range(runtime):

        log = "p1-runs/run" + str(n+1) + ".txt"

        stats = runGA(pop, cross, mute, log) # (gen, avgfit, bestfit)

        if stats == None:
            noneCount += 1
        else:
            generationsFound.append(stats[0])

    if (len(generationsFound) < 1):
        print("no successful runs")
    else:
        avg = mean(generationsFound)
        maxg = max(generationsFound)
        ming = min(generationsFound)

        print("Average Generation = ", avg)
        print("Max Generation = ", maxg)
        print("Min Generation = ", ming)
        print("nones = ", noneCount)

#end report

if __name__ == '__main__':
    #Testing Code
    print("Test Suite")

    # GAinspector.test(randomGenome)
    # GAinspector.test(makePopulation)
    # GAinspector.test(fitness)
    # GAinspector.test(evaluateFitness)
    # GAinspector.test(crossover)
    # GAinspector.test(mutate)
    # GAinspector.test(selectPair)

    #print(runGA(100, 0.7, 0.001, "p1-runs/run1.txt"))

    #reportTester(50, 100, 0.7, 0.001)
    reportTester(50, 100, 0.7, 0)